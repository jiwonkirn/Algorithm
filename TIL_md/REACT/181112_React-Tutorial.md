# 20181112 TIL Tutorial

[조은님과 강사님이 번역하신 REACT 공식 문서 링크](https://reactjs-org-ko.netlify.com/)

> 16.2 버전으로, 최신판은 아니다. (현재 최신판은 16.6)

## 튜토리얼

React를 사용하면, “컴포넌트”라 불리는 여러 격리된 코드 조각을 조합해서, 복잡한 UI를 쉽게 만들 수 있다.

### REACT는 **선언적**이다.

- 명령적 프로그래밍: DOM처럼 이렇게 동작시키라고 명령하는 형식의 프로그래밍 

    - 장점: 세세한 컨트롤이 가능하다.
    - 단점: 코드를 뜯어봐야 동작 방식을 알 수 있다.

- 선언적 프로그래밍: HTML처럼 선언해놓고 결과물의 

    - 장점: 코드가 생긴대로 나온다.

### REACT는 **효율적**이다.

DOM으로 정보가 변경되면 통째로 다시 그리는 방식을 사용하면 사람에게는 효율적이나 컴퓨터에게는 비효율적이다. 반대로 필요한 부분만 고치면 컴퓨터에게는 좋으나 코드가 길어지고 복잡해지기 때문에 사람에게 좋지 않다. **REACT는 사람과 컴퓨터 모두에게 효율적이다.**

### REACT는 유연하다.

UI를 값으로 다루기 때문에 유연하다.

```js
class ShoppingList extends React.Component { // 리액트 컴퍼넌트 라이브러리를 상속받아 클래스를 선언
  render() { // 메소드 선언 UI를 반환하는 render() 메소드를 가지고 있다.
    return ( // div 요소(UI)를 값으로 반환한다. 아래 코드는 HTML문서가 아니다. 뷰를 만들어내는 특별한 표현식이다.
      <div className="shopping-list">
        <h1>Shopping List for {this.props.name}</h1>
        <ul>
          <li>Instagram</li>
          <li>WhatsApp</li>
          <li>Oculus</li>
        </ul>
      </div>
    );
  }
}
```

- `뷰`: 어떻게 그릴건지에 다한 값. 위 HTML과 유사한 코드는 HTML문서가 아니다. 뷰를 만들어내는 특별한 표현식이다.
- `render` 메소드는 무엇을 그릴지에 대한 설명을 반환, 여기서 **render가 반환하는 것은 React 엘리먼트** (react div, react li ....)
- React 개발자들은 이러한 구조를 쉽게 표현할 수 있는 JSX라는 특별한 문법을 사용한다. SX 코드는, 빌드 과정에서 React.createElement('div')로 변환된다. 위 예제는 사실 바벨을 거치면  아래 코드와 같다

```js
return React.createElement('div', {className: 'shopping-list'}, // createElement는 객체를 반환한다.
  React.createElement('h1', /* ... h1 children ... */),
  React.createElement('ul', /* ... ul children ... */)
);
```

JSX 안에서는 JavaScript를 자유롭게 활용할 수 있다. JSX 중괄호 안에는 어떤 JavaScript 표현식도 넣을 수 있다. 그리고 React 엘리먼트는 JavaScript 객체로, 변수에 담거나 프로그램의 다른 부분으로 넘기는 것이 가능하다.

우리는 전체 쇼핑 목록을 그리기 위해 <ShoppingList />와 같이 쓸 수 있다. 각각의 React 컴포넌트는 독립적이며 캡슐화되어 있다. 이 성질은 우리가 단순한 컴포넌트로부터 복잡한 UI를 만드는 일을 가능하게 해 준다.


### `this.setState({})`

`this.setState({})`메소드 다음과 같은 기능을 할 수 있다. 

    - 상태를 변경한다. 
    - 화면을 갱신하는 기능을 할 수 있다.

> 리액트는 상태로부터 화면을 다시 그리는 것을 자동으로 한다. 즉, 화면으로 다시 그리라는 명령을 리액트에서 줄 일이 없다. 이는 화면을 다시 그리는 동작에 대해 체크할 필요가 없어지게 한다.

컴포넌트 안에서 setState를 호출하면, React는 해당 컴포넌트가 품고 있는 자식 컴포넌트까지 모두 새로 그려준다. (render 메소드가 전부 호출된다.)

#### 상태 끌어올리기

- 자식 컴포턴트의 상태를 부모 컴퍼넌트에서 불러오는 방법은 없다.

- 여러 자식 컴포넌트에 저장되어 있는 데이터를 읽어와야 할 때, 혹은 자식 컴포넌트끼리 통신을 해야 할 필요가 있을 때는, 부모 컴포넌트에서 상태를 공유하세요. 부모 컴포넌트에서는 prop을 통해 자식 컴포넌트에게 상태를 내려줄 수 있습니다. 이 방법을 통해 부모 컴포넌트와 자식 컴포넌트가 따로 놀지 않게 만들 수 있습니다.

- 상태를 공유해야하는 경우 가장 가까운 조상에서 공유한다.. (상태는 한군데에만 저장하는 것이 좋다. single source of truth)

- 부모의 상태를 직접 바꿀 수는 없는데, 부모가 상태를 변경시켜주는 함수를 자식에게 내어주면 간접적으로 변경할 수 있다.

- Square 컴포넌트가 상태를 갖지 않게 됨으로써, Square 컴포넌트는 Board 컴포넌트로부터 정보를 받고, 클릭되었을 때 그 사실을 Board 컴포넌트에게 알려줍니다. React 용어로 설명하면, Square 컴포넌트는 이제 제어되는 컴포넌트가 되었습니다. Board 컴포넌트가 이들을 완전히 제어하고 있습니다


- 화면 설계 => 상태를 어떻게 헐지 => 상태를 넘겨줌 => setState로 상태 변경

render메소드에서는 화면을 다시 그리는 것 이외의 코드는 절대 사용하면 안된다.
또한 엘리먼트 하나만 반환할 수 있다.