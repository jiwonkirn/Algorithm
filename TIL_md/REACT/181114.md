# 20181114 TIL

시작하기 전에 리액트는 ui를 값으로서 어떻게 잘 다뤄야 하는지를 고민해야 한다.

## 리스트와 키

### 키 

배열이나 iterator에는 각 요소마다 key값을 주어야 한다.

- 리액트는 배열이 추가되고 삭제됐을 때 정확히 어떤 것이 추가되고 삭제됐는지 알아야 한다. 키를 지정해주면 어떤 아이템이 바뀌었는지, 추가되었는지, 삭제되었는 지를 React에게 알려줄 수 있다. 배열에 들어있는 요소마다 식별자를 키로 넣어주도록 한다. (같은 배열의 키 값은 모두 달라야 한다.)

- 보통 서버에서 응답받은 객체 **data의 각 id값을 key**로 넘겨준다.

    > 할일 목록의 순서를 바꾸는 것 처럼 항목 간 순서가 바뀔 수 있는 경우 키에 인덱스를 사용하지 않는 게 좋다. 항목은 고유의 키 값을 가져야 학 그 키 값이 변경되어서는 안된다. 만약 **키 값을 변경되면 상태가 전부 날아가고 다시 그린다.** (생성자가 다시 호출된다.) 상태 초기화를 시키키 위해 키 값을 변경하는 경우도 종종 있다.

- internal instance tree: 리액트가 기억하고 있는 상태(개발자도구의 react elemnet 섹션)

    console에서 다음과 같이 입력하면 internal instance tree를 자세하게 확인 할 수 있다.
    ```js
    > const root = document.querySelector('#root')
    < undefined
    > root._reactRootContainer
    < ...
    ```

- (***) 리액트는 class의 인스턴스를 자동으로 생성해서 해당 class 컴포넌트에 붙여준다. 우리가 this라고 사용하는 것는 그 인스턴스를 만지는 것이고 그 인스턴스를 기준으로 동작한다. 인스턴스에 state가 저장되어 있고, `root._reactRootContainer`의 stateNode안에 인스턴스의 정보가 저장되어있다. 

    > 어떤 컴포넌트가 삭제되거나 다른 컴포넌트로 변경이 되면 (unmount 되면)인스턴스의 상태가 날아가고, 그 state 또한 전부 날아간다. 즉, **화면에 컴포넌트가 그려져야 인스턴스가 생성되고, 상태를 가진다. 컴포넌트(화면)가 지워지면 인스턴스, 상태 전부 날아간다.**

    > (Incorrect source) 함수형 컴포넌트는 함수이기 때문에 인스턴스를 가질 수 없다고 생각할 수 있지만, 어쨌든 함수형 컴포넌트에서도 인스턴스(리액트 요소들?)이 생성되기 때문에 이론상 상태를 가질 수 있고, 지금 리액트 팀에서 그 기능을 테스트 중이다.

- key는 아래에서 속성값(propps.key)으로 사용할 수 없다. 때문에 key의 내용을 사용하고 싶다면 다른 속성을 만들어서 똑같은 값을 기입하도록 한다.

    > 아래에서 받아올 수 없는 속성은 `key`, `ref` 두가지가 있다.

---

## 폼(form)

폼 엘리먼트 또한 상태(저장소)를 가진다. single soure of truth 이지만 이 기능을 바보로 만들 수도 있고 활용 할 수도 있다. form의 상태가 잘못된 방향으로 흘러갈 때 피드백을 줄 수 있어야 한다. (한글만 써야 하는데 영어를 쓴다던가, 특수문자가 있어야 하는데 없다던가...)

### 제어되는 컴포넌트 (Controlled Components)

HTML에서 <input>, <textarea>, <select> 같은 form 요소는 자기만의 상태를 가지고 사용자의 입력에 따라 업데이트된다. 반면에 React에서는, 변경 가능한 상태를 일반적으로 컴포넌트의 state 속성에 위치시키며, 이는 setState()로만 업데이트할 수 있다.

React state를 “진리의 유일한 원천 (single source of truth)“으로 만들어 두 세계를 결합할 수 있다. 이렇게 하면 사용자의 입력에 따라 폼에서 발생되는 일을 React 컴포넌트 측에서 제어하게 된다. 이런 방식으로, React에 의해 제어되는 input 폼 요소를 “제어되는 컴포넌트” 라고 부른다.

> 예를 들어 input에 value값을 지정하고 onChange이벤트를 주지 않는다면 사용자가 입력 할 수 없다. value값이 강제로 지정되어있는 상태에서 이벤트 핸들링을 해주지 않기 때문에다. input에 입력이 일어났을 때(change 이벤트가 발생했을 때) state를 바꿔주는 콜백을 넘겨줌으로써 상태를 state를 기반으로 다시 그려준다. 이 것은 제어되는 컴포넌트이다.

> 리액트에서는 input 이벤트가 아닌 onChange를 사용하면 된다.

### textarea

textarea도 onChange 이벤트핸들러를 통해 제어할 수 있다.

### select

selected 대신에 select의 value속성을 option의 value속성을 일치시켜주면 selected와 같은 효과를 받을 수 있다.

### 제어되는 컴포넌트의 대안책

제어되지 않는 컴포넌트를 컨트롤하기 위해서는 DOM객체를 REACT세계로 가져와야한다. `ref`를 통해 가져 올 수 있다.

> 전부 제어되는 컴포넌트로 만들기 위해서는 많은 코드를 입력해야 한다. (복잡성 증가) 

라이브러리를 사용하는 방법이 있다.. [formik 라이브러리]

---