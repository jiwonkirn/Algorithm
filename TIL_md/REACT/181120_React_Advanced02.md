
# 181119 TIL React Advanced 

## 제어되지 않는 컴포넌트

제어되지 않는 컴포넌트는 진리의 원천을 DOM에 두기 때문에, React를 사용한 코드와 사용하지 않은 코드를 통합하는 작업을 좀 더 쉽게 만들어줄 수 있다.
(= 코드의 양이 줄어든다.)

> 좀 지저분하지만 빠른 해결책을 원한다면 

### 기본값 지정

html에서는 input에 기본값을 줄 때 `value`속성을 주었지만 리액트에서 `value`속성을 사용하면 제어되는 컴포넌트가 되지 때문에, 기본값을 주고 싶은 경우 `defaultValue`속성을 사용한다. 비슷하게 `<input type="checkbox">`와 `<input type="radio">` 엘리먼트는 `defaultChecked` 어트리뷰트를, `<select>`와 `<textarea>`는 `defaultValue` 어트리뷰트를 지원한다.

>  제어되는 = checked, 제어되지않는 = defaultChecked

### The file input Tag

`<input type="file" />`은 파일을 업로드하는 input으로, `event.target.files` 돔 객체에는 파일 정보가 들어있다. 리액트에서는 `<input type="file" />`를 제어되는 컴포넌트로 사용할 수 없다. (이 엘리먼트의 값은 오로지 사용자에 의해서만 지정될 수 있기 때문이다.)

---

## 성능 최적화

아래는 성능 최적화 파트, 비교조정 (Reconciliation) 피하기 부터의 내용 요약

> React 개발자가 된다면 나중에 한번 더 읽어봐야한다. 리액트 함수는 순수함수여야한다.

**setState가 일어나면 해당 컴포넌트의 자식 컴포넌트를 모두 호출해본다.**(render메소드를 다시 호출) 그러므로 최상위 컴포넌트인 APP컴포넌트에서 상태가 (자주) 바뀌면 성능상 큰 문제가 생긴다.

> DOM객체는 부분적으로 바꾸지만 해당 리액트 컴포넌트 자체는 전부 호출된다.

하지만 props 와 state의 속성이 바뀌지 않는다면 render 메소드를 호출할 필요가 없다. 그러므로 state가 업데이트될 때만 render메소드를 호출해야할 필요가 있고 이를 최적화된 컴포넌트라한다. 최적회가 된 컴포넌트는 `React.PureComponent`를 상속받을 클래스로 지정하고 사용한다.

`PureComponent`를 적용하면, `state`와 `props`속성이 변경되었을 때만 render 메소드를 호출해서 화면을 새로 그린다. state나 props에 참조 타입의 값(배열 혹은 객체)이 들어있다면, 배열이나 객체의 내용이 바뀌어도, 참조가 바뀌지 않는 한, React는 화면을 새로 그리지 않는다. 때문에 새로운 배열을 복사해서 생성해서 참조를 변경해줘야 한다.

> 참조만 비교하는 이유는, 깊은 비교(내용 비교)를 하는 것이 비싼 연산이기 땨문이다. 성능 최적화가 목적인 PureComponent는 깊은 비교를 하지 않는다(참조만 비교한다).

### 불변성

불변성을 다시 정의하자면, **내용이 변경되었을 때 참조 역시 변경되면 그 것이 불변이다.** (내용이 바뀌었는지 확인하기 위해 참조만 확인하면 된다. 깊은 비교는 비싸기 때문이다.) 성능 최적화를 위해 객체나 배열을 불변인 것 처럼 다루는 것이 좋다. 

- [immutable.js](https://facebook.github.io/immutable-js/)는 객체나 배열을 불변인 것 처럼 다루게해주는 라이브러리로, 오브젝트 복사가 번거롭다면 사용하는 것도 좋다. 하지만 내장된 객체나 배열을 사용하는 것이 아니라 만들어진 배열과 객체를 사용한다.

- [immer](https://github.com/mweststrate/immer)는 내장 객체나 배열을 사용하고, 기존 메소드를 그대로 사용할 수 있으며, 오브젝트를 불변인 것처럼 다룰 수 있다.

[React에서 immutable.js를 사용하면 왜 좋은지?](https://velopert.com/3486)

#### 불변성의 단점

- 매번 새로 참조를 만들어준다면 공간을 많이 차지하게 되고, 값을 자주 바꿔줘야하는 (게임과 같은)일에는 불변성을 사용하는 것이 좋지 않다.

### PureComponent가 default가 아닌 이유

어쨌는 배열이나 객체를 복사하는 동작도 값이 드는 행위이기 때문에 상태가 자주 바뀌지 않는 프로그램에서는 `PureComponent`를 사용하지 않는 것이 좋다.

### 비교조정 (Reconciliation) 피하기

일부 상황에서 컴포넌트를 업데이트할 필요가 없는 경우 `shouldComponentUpdate` 에서 `false` 를 반환하여 이 컴포넌트 및 하위에서 호출하는 render() 를 포함한 전체 렌더링 프로세스를 스킵할 수 있다. `PureComponent` 내에 `shouldComponentUpdate`가 내장 되어있다.

```js
shouldComponentUpdate(nextProps, nextState) {
  return true;
}
```

> 성능 최적화 이슈에 대해 면접 문제로 나올 수 있다.


## 비교조정 (Reconciliation)

 React는 어플리케이션 작성을 더욱 쉽게 만들어주지만, 내부에서 어떤 일이 일어나고 있는지는 명확히 눈에 보이지 않는다. 이 글에서는 우리가 React의 “비교” 알고리즘을 만들 때 어떤 선택을 했는지를 소개한다.

 > 알고리즘 복잡도의 정도를 표기할 때, O(n3): 느리다. O(n), O(log): 빠르다

 1. 다른 타입을 가진 두 엘리먼트는 다른 트리를 만들어 낼 것이다.

 => 하위 엘리먼트는 (변경되지 않으면) 그냥 새로 그린다.

 2. 개발자가 제공한 key prop을 이용해, 여러 번의 렌더링 속에서도 변경되지 말아야 할 자식 엘리먼트가 무엇인지를 알아낼 수 있을 것이다.

이 전과 지금을 비교했을 때, 엘리먼트 타입, key가 바뀌면 더 이상 비교를 하지 않고 통째로 새로 그린다. (비교 횟수를 줄인다.)

### 비교 알고리즘

위에서부터 아래로 비교해나간다. 

#### 다른 타입의 엘리먼트인 경우

트리를 버릴 때, 이전 DOM 노드들은 모두 파괴된다. 트리가 바뀌면 이 전 트리에 연결되어 있던 state는 모두 사라진다. (자식의 자식 state 또한 모두 삭제된다.)

```js
<div>
  <Counter />
</div>

// 아래의 Counter의 상태는 다 날아가고(unmount) 다시 호출된다.(mountś
<span>
  <Counter /> 
</span>
```

#### 같은 타입의 DOM 엘리먼트인 경우

클래스나 속성의 경우는 변경된 클래스나 속성만 갱신한다. (unmount되지 않는다.)

하나의 DOM 노드를 처리한 뒤에, React는 뒤이어 해당 노드의 자식들을 재귀적으로 처리합니다. => **하위 요소에 대해서 같은 방식으로 처리한다.**

#### 같은 타입의 컴포넌트 엘리먼트인 경우 (Custom Element)

쉽게 말해서 라이프 사이클 훅이 호출되고 prop이 바뀌 뿐, 날아가는 것은 거의 없다.

#### 키

리액트는 우리가 정확히 어떻게 변경하려 하는지 알아보기 위해서 `key`속성을 사용하며, 추가해야 한다. 만약 키를 추가하지 않으면 순서만을 확인하고 처리해서 모든 배열에 대해 덮어씌우기가 발생한다.

같은 형제들 간에 key값이 같으면 안되고, 한 번 지정된 key값은 변경하면 안된다.

 key가 바뀌면 더 이상 비교를 하지 않고 통째로 새로 그리기 때문에 상태를 새로 그리고 싶을 경우 key값을 바꾸기도 한다.
