# 부동 소수점 (float-point)

실수를 컴퓨터 상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것이다.

## 단정도와 배정도 (혹은 단정밀도, 배정밀도)

1. 단정도 (single precision)

32bit(4byte)의 메모리를 차지하는 자료형으로 부호(1bit), 지수(8bit), 가수(23bit)로 메모리에 저장된다. C언어의 `float`자료형

2. 배정도 (double precision)

64bit(8byte)의 메모리를 차지하는 자료형으로 부호(1bit), 지수(11bit), 가수(52bit)로 메모리에 저장된다. C언어의 `double`자료형

## 정규화

정규화(normalization)이란 소수점 왼쪽에 위치한 가수부분을 밑수보다 작은 자연수가 되도록 만드는 것이다. 예를 들면 다음 10진수 492.62는 다음과 같이 정규화한다.

```
492.62 === (4.9262 * 10 ^ 2);
```

소수점 왼쪽에 위치한 가수부분이 10진수의 밑수인 10보다 작아야하므로 `4.9262 * 10^2`가 됐다. 2진수의 경우 밑수가 2기 때문에 정규화된 가수 부분의 소수점 왼쪽 부분은 1일 수 밖에 없으므로 메모리에 저장할 때 소수점 왼쪽 부분은 자르고 저장하게 된다.

## 메모리에 저장

앞서 부동소수점을 메모리에 저장한다고 했을 때, 32bit의 메모리(단정도)에 할당한다고 한다면 1bit는 부호, 8bit는 지수, 23bit는 (정규화한 소수점 왼쪽 1을 제외한)가수 부분이 된다. 그런데 숫자가 작아져 지수가 음수가 된다면 8bit의 지수 부분에 음수를 어떻게 표기할지 의문이 든다. 8bit 지수 맨 앞자리를 부호로 나타내지 않을까 싶을 수 있지만 `bias`라는 것을 통해 메모리에 표기한다.

### bias

우선 단정도(32bit) 기준으로 0부터 255의 수를 저장할 수 있다. 때문에 지수에 +127을 한 값을 지수부에 저장하면 메모리를 읽을 때 지수부 - 127을 해서 해당 지수를 정확하게 읽을 수 있다. 결국 bias는 단정도에서는 `(2^8 - 1) / 2` 가 되고, 배정도에서는 `(2^11 - 1) / 2`가 된다.

결국 메모리에 저장할 때 다음과 같은 과정을 통해 저장이 된다.

- 1bit: 부호, 0은 양수 1은 음수.
- 8bit(11bit): 지수 + bias
- 23bit(52bit): 정규화한 2진수의 맨 앞자리를 제외한 수

단정도로 예를 든다면 다음과 같이 저장된다.

```py
11.75           # 10진수
1011.11         # 2진수
1.01111 * 2^3   # 정규화

# 메모리 저장
0 # 부호(양수)
10000010 # 지수, 3 + 127 => 130
01111000000000000000000 # 정규화한 가수에서 맨 왼쪽 1을 제외한 나머지
01000001001111000000000000000000 # 최종적으로 메모리에 저장된 형태
```

## 정밀도

컴퓨터에서 `0.1 + 0.2` 연산을 하게되면 `0.30000000....7`이라는 결과같을 갖게 된다. 이는 결과값의 가수가 `53bit`안에 들어오지 못했기 때문에 뒤의 수가 반올림되어 반환됐기 때문이다. 때문에, 컴퓨터는 `53bit`를 초과하는 수에 대해서는 정밀도가 떨어지게 된다. 때문에 컴퓨터가 연산을 할 때 정밀도가 보장되는 숫자는 2진수 53자리이다. (10진수는 15자리(2^53))

> 가수는 52bit로 저장되지만 정규화된 맨 왼쪽 부분이 제외된 메모리 이므로 53bit까지이다. 단정도의 경우 24bit.

### 앱실론 (epsilon)

앱실론은 컴퓨터가 1 다음에 표현할 수 있는 수의 단위이다. 단정도의 경우 `2^-23` 배정도의 경우 `2^-52`이다.

### 앱실론 (epsilon)의 쓰임

수를 2진수로 하여 정규화한 뒤, `2^지수`를 앱실론을 곱하면 해당 수 다음에 표현 가능한 수를 알 수 있다. 예를 들어, 다음과 같은 방법으로 10.5 다음에 표현 가능한 수를 알 수 있다.

```py
10.5
1010.1
1.0101 * 2^3 # 2^3 에 앱실론을 곱해야한다.
2^3 * 2^-23 === 2^-20 # 10.5 다음에 표현 가능한 수는 10.5 + 2^20이다.
```

다음과 같은 성격을 활용하면 컴퓨터가 소수를 연산하는 데서 오는 예상치 못한 결과같에 대한 예상할 수 있는 비교를 할 수 있다.

위 예제의 정규화된 수를 통해 어느 정도 오차가 미비한 비교를 할 수 있다.

- `2^e <= num의 절대값 <= 2^e+1`
- `2^e * epsilon` 혹은 `2^e+1 * epsilon`은 `num의 절대값 * epsilon`과 거의 유사하다.

```
> 이진수 1.0101 * 2^3
> 2^3 <= 1.0101 * 2^3 <= 2^4

# 아래 두 결과값은 유사하다.
> 2^3 * 2^-23
> 1.0101 * 2^3 * 2^-23
```

위의 방법과 유사하게 `0.2 + 0.1`과 `0.3`이 같은지를 비교하는 함수를 상대적인 비교 방법으로 간단하게 작성할 수 있다.

```js
function isEqual(a, b, allowed = 0) {
  const eqs = Math.pow(2, -52); // 자바스트립트는 모든 실수가 double 자료형이다. 때문에 2^-52
  const diff = Math.abs(a - b); // (0.2 + 0.1) - 0.3 의 절대값

  // 두 수 중 큰 수에 epsilon을 곱하면 그 수와 그 이웃하는 수 차이의 근사값
  return (
    diff <= Math.max(Math.abs(a), Math.abs(a)) * eps * Math.pow(2, allowed)
  );
}

console.log(isEqual(0.2 + 0.1, 0.3, 1)); // true
console.log(0.2 + 0.1 === 0.3); // false
```
