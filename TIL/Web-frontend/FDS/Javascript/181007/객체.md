# 객체
## 대괄호 표기
속성 접근자(property accessor)를 이용해 이미 생성된 객체의 속성을 지정, 선택해줄 수 있는데 식별자 규칙에 어긋나는 속성명은 대괄호를 사용한다.
```js
const obj = {};
person['한국 나이'] = 20;
```

또한 변수에 저장된 문자열을 속성명으로 사용하려면 역시 대괄호를 사용한다.
```js
const propName = 'prop';

const obj = {
  [propName]: 1
};

obj.prop; // 1
```

---
## 객체 속성 삭제, 확인
`delete`
속성을 삭제한다. 프로토타입의 속성을 삭제할 수 없다.
```js
// 속성 삭제하기
delete person.address;
```

`in`
속성이 객체 안에있는지 확인한다. 작은 따옴표 문자열에 속성명을 넣는다.
```js
'name' in person; // true
'phoneNumber' in person; // false
```

---
## this
`this` 키워드를 사용하면, 메소드 호출 시에 해당 메소드를 갖고 있는 객체에 접근할 수 있다. 이는 메소드가 함수와 구별되는 이유이다.
```js
const person = {
  name: '윤아준',
  age: 19,
  introduce() {
    // `this`를 사용해서 객체의 속성에 접근함
    return `안녕하세요, 제 이름은 ${this.name}입니다. 제 나이는 ${this.age}살 입니다.`
  },
  getOlder() {
    // `this`를 사용해서 객체의 속성을 갱신함
    this.age++;
  }
};

person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 19살 입니다.'
person.getOlder(); // undefined
person.introduce(); // '안녕하세요, 제 이름은 윤아준입니다. 제 나이는 20살 입니다.'
```

메소드를 사용하면, 데이터와, 그 데이터와 관련된 동작을 객체라는 하나의 단위로 묶어서 다룰 수 있다. 
```js
function introduce() {
  return `안녕하세요, 제 이름은 ${this.name}입니다.`;
}

const person1 = {
  name: '윤아준',
  introduce
};

const person2 = {
  name: '신하경',
  introduce
};

person1.introduce(); // 안녕하세요, 제 이름은 운아준입니다.
person2.introduce(); // 안녕하세요, 제 이름은 신하경입니다.
```

어떤 객체의 메소드로 사용되느냐에 따라 메소드 내부의 this가 가리키는 객체가 달라질 수 있다. 하지만 화살표 함수에서는 this를 다른 방식으로 취급하기 때문에 동작하지 않는다

---
## 프로토타입 문법
* `Object.create()`: ()안의 객체의 상속받는 객체를 생성한다.

* `Object.getPrototypeOf()`: ()안의 프로토타입이 무엇인지 찾는다.

* `Object.setPrototypeOf(child, parent)`: child 객체의 프로토타입을 parent로 바꾼다.

* `obj1.isPrototypeOf(obj3)`: obj3의 프로토타입에 obj1이 있는지 확인한다.

* `new 객체명`: 객체를 상속받는 새로운 객체를 선언한다. 프로토타입이 되는 객체 혹은 함수는 첫 글자를 대문자로 짓는 것이 관례이다.

* `A instanceof B`: 생성자를 통해 생성된 객체를 그 생성자의 인스턴스라고 한다.  B는 A의 인스턴스인가? 를 물어보는 것이다.

### constructor

생성자의 `prototype` 속성에 자동 생성되는 객체에는 `constructor`라는 특별한 속성이 들어있다. 이 속성에는 생성자 자신이 저장된다.
```js
function Person() {
  // ...
}
Person.prototype.constructor === Person; // true

const person = new Person();
person.constructor === Person; // true
```

### 정적 메소드 (Static Method)

생성자의 속성에 직접 지정된 메소드를 가지고 정적 메소드(static method)라고 한다. 우리가 이제까지 유용하게 사용했던 Number.isNaN, Object.getPropertyOf 등의 함수들은 모두 정적 메소드다. 정적 메소드는 특정 인스턴스에 대한 작업이 아니라, 해당 생성자와 관련된 일반적인 작업을 정의하고 싶을 때 사용된다.
```js
// 생성자의 속성에 함수를 직접 할당합니다.
Person.compareAge = function(person1, person2) {
  if (person1.age < person2.age) {
    return '첫 번째 사람의 나이가 더 많습니다.';
  } else if (person1.age === person2.age) {
    return '두 사람의 나이가 같습니다.';
  } else {
    return '두 번째 사람의 나이가 더 많습니다.';
  }
}

// 여기서 person1과 person2는 Person 생성자에 의해 생성된 인스턴스이다.
생성자의 속성을 지정해 메소드를 추가하는 것으로 매개변수를 인스턴스로 지정하는 것이다.
```







