# FDS12 컴퓨터의 이해

패스트캠퍼스 FDS 12기 양태환 강사님 수업 내용 노트입니다.

- Recursion: 재귀
- index: 배열 인덱싱
- sort: 정렬
  - 현업에서는 quick sort가 가장 많이 사용된다.
- binary search: 이진 탐색

- stack, heap: 메모리 레이아웃, 메모리 계층 => 세그먼트
- process / thread

- call by value / call by reference => 함수

- Write simple text-based games

## memory

### memory 주소

cpu와 ram 사이에서 데이터를 주고 받을때 전압으로 알아차립니다.(약 5v: 1, 약 0v: 0) 와이어(레지스터) 하나당 0과 1을 표현할 수 있다는 뜻인데, cpu와 ram 사이에 연결된 와이어의 숫자로 bit를 결정합니다. 즉 와이어가 32bit라면 `2 ** 32` 의 수를 RAM과 CPU가 공유할 수 있다는 의미입니다.

- 32bit
- 64bit

## memory 주소값

메모리에서는 하나의 주소값에 1byte(8bit)를 할당할 수 있습니다. 메모리 접근을 byte로 하는 것입니다. digit을 저장하는데 32, 64bit 2진수로 저장한다는 것은 각각 `2 ** 32`, `2 ** 64`의 주소값을 저장할 수 있습니다. `2 ** 32` => 4G, `2 ** 64` => 16EB (18000TB)

> 32bit 컴퓨터에 4G를 초과하는 메모리를 가질 수 없다. 이론상 64bit의 컴퓨터는 16EB의 메모리를 가질 수 있지만, 현재의 RAM은 192GB까지 가질 수 있다고 합니다.

> bit로 나타내는건 시작 주소인데 이는 단순히 말하면 몇 버째 칸인지 나타낸다고 보시면 됩니다 실제 메모리에서는 최소단위인 한 칸이 바이트 단위이기 때문에 4g칸 × 바이트 단위 4GB가 됩니다

## 수

### 정수, 실수

- 정수(integer): 음수, 0, 양수입니다.

- 실수(float): 소수점의 수, 컴퓨터가 효율적으로 실수를 처리하기 위해서 특별한 방식으로 실수를 처리합니다. 때문에 실수의 동작 방식 혹은 실수 연산의 특이점을 이해하고 사용하는 것이 좋습니다.

```js
const num1 = 0.3; // 0.3
const num2 = 0.1 + 0.2; // 0.30000000000000004
console.log(num1 === num2); // false
```

> [IEEE 754](https://ko.wikipedia.org/wiki/IEEE_754): 전기 전자 기술자 협회(IEEE)에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준

### 2진수, 10진수, 16진수

한 자리수(digit)로 표현할 수 있는 숫자의 개수

- 10진수: 10개의 밑수(== base, == radix)

  - 0 ~ 9

- 2진수: 2개의 밑수(== base, == radix)

  - 0, 1

- 10진수: 10개의 밑수(== base, == radix)

  - 0 ~ 9, a ~ f

> 32bit => 2진수 32자리 => 16진수 8자리 => 메모리 주소 `0xab124516`

#### 10진수 => 2진수

37 -> 32(5) + 4(2) + 1(0) -> 100101

#### 16진수 => 2진수

2진수의 네자리씩을 가집니다.

- a => 1010
- b => 1011
- c => 1100
- d => 1101
- e => 1110
- f => 1111

```
0b011111011 => 0x7b
```

> 때문에 16진수 2자리는 1byte

### 수와 메모리

#### 정수 (Integer)

- 일반적으로 1byte, 2byte, 4byte, 8byte에 저장합니다.
- 부호가 있는 정수(signed)와 부호가 없는 정수(unsigned)로 나뉩니다.
- 부호가 있는 경우 첫 bit가 부호를 나타냅니다. (0: 양수, 1: 음수)

integer에 1byte를 할당한다고 했을 때, -2**7 ~ (2**7 - 1) 까지 표현할 수 있습니다. 만약에 해당 범위를 벗어나면 `integer overflow`가 일어난다. 이런 **소프트웨어의 취약점**을 이용해서 해킹을 하는 경우도 있다.

> 만약 127에 1을 더해서 `integer overflow`가 일어나면 값이 -128, +2를 하면 -127 리언식으로 시작점에서 더해나간다.

- char: 1byte (-2^7 ~ 2^7-1)
- unsigned char: 1byte (0 ~ 2^8-1)
- short: 2byte (-2^15 ~ 2^15-1)
- short: 2byte (0 ~ 2^16-1)
- int: 4byte (-2^31 ~ 2^31-1)
- int: 4byte (0 ~ 2^32-1)

> 원래 signed 정수의 경우 첫 자리가 1이면 -, 0이면 + 이다. 예를 들어 `-27`은 `10011011` 하지만 이 걍우 10000000, 00000000는 -0, +0이므로 논리 연산에서 원하는 동작을 하지 않는다. 때문에 2의 보수 개념이 적용된다.

3의 자리수가 바뀌지 않으면서 가장 큰 수는 9, 6은 3의 9의 보수
25의 자리수가 바뀌지 않으면서 가장 큰 수는 99, 74은 25의 9의 보수
257의 자리수가 바뀌지 않으면서 가장 큰 수는 999, 742은 257의 9의 보수, (742 + 1)은 257의 10의 보수!

1010의 1의 보수는 0101, 2의 보수(반전 보수)는 0110. 즉 1100 => (1의보수를 구한다. 비트가 반전된다.) => 0011 => (2의 보수를 구하기 위해 +1) => 0100

ALU: 산술 연산 / 논리 연산을 하는 가산기 역할을 한다(덧셈만 가능하다). 논리 연산을 할 때는 a - b == 0과 같은 연산을 한다. 10000 - 00000은 0이 나오지 -10000기 때문에 0이 아니다.

43 => (2진수) => 00101011 => 11010100(1의 보수) => 11010101(2의 보수)

```
127 => 01111111(signed 2진수) => 10000001(2의 보수) => -127
1 => 00000001(signed 2진수) => 11111111(2의 보수) => -1
10000000 => -128
```

> 레지스터: CPU에 있는 가장 빠른 메모리

- `c = a + b`를 연산하려고 한다면..

RAM에서 레지스터 eax에 a값을 저장, 레지스터 ecx에 b값을 저장, ALU가 둘을 더해서 eax에 저장, exa의 값을 RAM의 c에 저장.

이를 인스트럭션 (기계어)라고 한다.

> `43 - 25` = `00101011 + 11100111` => `100010010`(여기서 1은 버린다.) => `00010010` => `18`

##### 곱셈

adder, shift register

#### 실수

- float: 4byte
- double: 8byte

> javascript는 무조건 double로 8byte를 잡아먹기 때문에 수 연산에 약합니다. 즉 리소스를 많이 잡아먹습니다.

#### 부동 소수점

정밀도는 떨어지고 표현 범위는 높아진다. 부동소수점의 연산에 있어서 비교 연산을 하게 된다면 원하는 대로 동작하지 않을 수 있으므로 `is_equal`같은 함수를 사용해서 비교하도록 한다.

예전에는 고정 소수점을 사용하여 네자리 정수, 네자리 소수로 표현했으나, 1byte에 -2^3 ~ 2^3-1 까지밖에 표현을 못하게 되어 부동소수점이 고안되었다.

## 문자

ASCII, UNICODE

> RGB: 1byte(8bit) 이기 때문에 0 - 255
